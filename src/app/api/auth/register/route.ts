import { NextRequest, NextResponse } from "next/server";
import { prisma } from "@/lib/prisma";
import bcrypt from "bcryptjs";
import { registerSchema, validateSchema } from "@/lib/zod-schemas";

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('üìù Registration attempt with data:', body);

    // –í–∞–ª–∏–¥–∞—Ü–∏—è —Å –ø–æ–º–æ—â—å—é Zod
    const validationResult = validateSchema(registerSchema, body);
    console.log('üîç Validation result:', validationResult);
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          message: "–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö", 
          errors: validationResult.errors,
          isValidationError: true 
        },
        { status: 400 }
      );
    }

    let { name, email, telegram, password } = validationResult.data;
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º telegram - –¥–æ–±–∞–≤–ª—è–µ–º @ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
    if (telegram && !telegram.startsWith('@')) {
      telegram = '@' + telegram;
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ email
    const existingUser = await prisma.users.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (existingUser) {
      return NextResponse.json(
        { 
          message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç", 
          errors: { email: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç" },
          isValidationError: true 
        },
        { status: 409 }
      );
    }

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ telegram
    const existingTelegram = await prisma.users.findUnique({
      where: { telegram: telegram.toLowerCase() },
    });

    if (existingTelegram) {
      return NextResponse.json(
        { 
          message: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º Telegram —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç", 
          errors: { telegram: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º Telegram —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç" },
          isValidationError: true 
        },
        { status: 409 }
      );
    }

    // –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
    const hashedPassword = await bcrypt.hash(password, 10);

    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.users.create({
      data: {
        name: name.trim(),
        email: email.toLowerCase(),
        telegram: telegram.toLowerCase(),
        password: hashedPassword,
        role: "USER", // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–æ–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        status: "PENDING", // –¢—Ä–µ–±—É–µ—Ç—Å—è –æ–¥–æ–±—Ä–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
      },
    });

    // –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ (–≤—Ä–µ–º–µ–Ω–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–æ)
    // await prisma.analytics.create({
    //   userId: user.id,
    //   action: 'user_registered',
    //   metadata: JSON.stringify({
    //     event: "user_registration",
    //     email: user.email,
    //     userAgent: request.headers.get("user-agent"),
    //   }),
    // });

    return NextResponse.json({
      message: "–ó–∞—è–≤–∫–∞ –Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—é –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞! –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä —Ä–∞—Å—Å–º–æ—Ç—Ä–∏—Ç –µ—ë –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.",
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        telegram: user.telegram,
        role: user.role,
        status: user.status,
      },
    });
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:", error);
    return NextResponse.json(
      { message: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" },
      { status: 500 }
    );
  }
}
